package com.nbilyk.utils {	import flash.display.GradientType;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Rectangle;		import mx.core.UIComponent;	import mx.styles.CSSStyleDeclaration;	import mx.styles.StyleManager;	import mx.utils.GraphicsUtil;		[Deprecated]	public class StyleUtil {		public static function drawRoundRectFromCss(target:UIComponent, rect:Rectangle, gradientType:String = "linear"):void {			// retrieves the user-defined styles			var fillColors:Array = target.getStyle("gradientFillColors");			if (fillColors) {				var fillAlphas:Array = target.getStyle("gradientFillAlphas");				var ratios:Array = target.getStyle("gradientFillRatios");				var cornerRadius:Number = target.getStyle("cornerRadius");				drawRoundRectSimple(target, rect, cornerRadius, fillColors, fillAlphas, ratios, gradientType);			}		}		public static function drawRoundRectSimple(target:Sprite, rect:Rectangle, cornerRadius:Number, fillColors:Array, fillAlphas:Array, ratios:Array = null, gradientType:String = "linear"):void {			if (!fillColors) return;			var i:uint;			var n:uint = fillColors.length;			if (!fillAlphas) {				fillAlphas = new Array(n);				for (i = 0; i < n; i++) {					fillAlphas[i] = 1;				}			}			if (!ratios) {				ratios = new Array(n);				ratios[0] = 0;				for (i = 0; i < n; i++) {					ratios[i] = i * (0xFF / (n - 1));				}			}						StyleManager.getColorNames(fillColors);			target.graphics.clear();			var gradientMatrix:Matrix = new Matrix();			gradientMatrix.createGradientBox(rect.width, rect.height, Math.PI / 2, rect.x, rect.y);			drawRoundRect(target, rect.x, rect.y, rect.width, rect.height, cornerRadius, fillColors, fillAlphas, gradientMatrix, gradientType, ratios);		}		public static function drawRoundRect(target:Sprite, x:Number, y:Number, w:Number, h:Number, r:Object = null, c:Object = null, alpha:Object = null, rot:Object = null, gradient:String = null, ratios:Array = null, hole:Object = null):void {            var g:Graphics = target.graphics;            // Quick exit if w or h is zero. This happens when scaling a component            // to a very small value, which then gets rounded to 0.            if (!w || !h)                return;            // If color is an object then allow for complex fills.            if (c !== null) {                if (c is Array) {                    var alphas:Array;                    if (alpha is Array)                        alphas = alpha as Array;                    else                        alphas = [ alpha, alpha ];                    if (!ratios)                        ratios = [ 0, 0xFF ];                    var matrix:Matrix = null;                    if (rot) {                        if (rot is Matrix) {                            matrix = Matrix(rot);                        } else {                            matrix = new Matrix();                            if (rot is Number) {                                matrix.createGradientBox(w, h, Number(rot) * Math.PI / 180, x, y);                            } else {                                matrix.createGradientBox(rot.w, rot.h, rot.r, rot.x, rot.y);                            }                        }                    }                    if (gradient == GradientType.RADIAL) {                        g.beginGradientFill(GradientType.RADIAL, c as Array, alphas, ratios, matrix);                    } else {                        g.beginGradientFill(GradientType.LINEAR, c as Array, alphas, ratios, matrix);                    }                } else {                    g.beginFill(Number(c), Number(alpha));                }            }            var ellipseSize:Number;            // Stroke the rectangle.            if (!r) {                g.drawRect(x, y, w, h);            } else if (r is Number) {                ellipseSize = Number(r) * 2;                g.drawRoundRect(x, y, w, h, ellipseSize, ellipseSize);            } else {                GraphicsUtil.drawRoundRectComplex(g, x, y, w, h, r.tl, r.tr, r.bl, r.br);            }            // Carve a rectangular hole out of the middle of the rounded rect.            if (hole) {                var holeR:Object = hole.r;                if (holeR is Number) {                    ellipseSize = Number(holeR) * 2;                    g.drawRoundRect(hole.x, hole.y, hole.w, hole.h, ellipseSize, ellipseSize);                } else {                    GraphicsUtil.drawRoundRectComplex(g, hole.x, hole.y, hole.w, hole.h, holeR.tl, holeR.tr, holeR.bl, holeR.br);                }            }            if (c !== null)                g.endFill();        }				[Deprecated]		public static function applyStyles(uiComponent:UIComponent, styleName:String, defaultStylesObject:Object):void {			var cssStyleDeclaration:CSSStyleDeclaration = StyleManager.getStyleDeclaration("." + styleName);			for (var all:String in defaultStylesObject) {				if (!cssStyleDeclaration || !cssStyleDeclaration.getStyle(all)) {					uiComponent.setStyle(all, defaultStylesObject[all]);				}			}			uiComponent.styleName = styleName;		}	}}